제미나이 CLI와 디스코드를 활용한 챗옵스 구축기

발표주제

Gemini CLI(Command Line Interface)와 Discord를 연동하여 모니터링 및 인시던트 대응을 자동화하는 챗옵스(ChatOps) 시스템 구축 사례

요약

본 발표는 알림 발생 시 PC를 켜서 원인을 분석하고 조치해야 하는 번거로움을 스마트폰 채팅으로 해결하고자 시작된 프로젝트를 다룬다. Gemini CLI와 Discord 봇을 파이썬 코드로 연동하여, 채팅 명령어로 모니터링 시스템(Prometheus, Alarm Manager)을 제어하는 챗옵스 시스템을 구축했다. 구현 과정에서 CLI 방식의 한계로 인해 이전 대화 내용을 기억하지 못하는 문제와, 대화가 길어질수록 토큰 사용량이 급증하고 응답 속도가 느려지는 심각한 성능 저하 문제가 발생했다. 발표자는 이러한 문제들을 완전히 해결하지 못했기에 이 프로젝트를 '실패'로 규정하고, 향후 개선 방안을 공유한다.

발표내용

1. 도입 배경

* 문제 인식: 휴식 중 슬랙이나 디스코드 등에서 시스템 알람이 울릴 경우, 사용자는 PC를 켜고, 원인을 분석한 뒤, 조치를 취해야 하는 번거로운 과정을 거쳐야 한다. (04:34)
* 프로젝트 목표: 이러한 과정을 스마트폰 채팅만으로 간단하게 해결할 수 있는 챗옵스(ChatOps) 시스템을 구축하고자 했다. (05:27)

2. 기술 구현 및 과정

* 기본 설정:
  * NPM을 통해 Gemini CLI를 설치. (05:27)
  * 구글 리디렉션을 통해 받은 토큰 값을 입력하여 로그인.
* 외부 시스템 연동:
  * AI 에이전트가 프로메테우스(Prometheus), 알람 매니저(Alarm Manager) 같은 외부 시스템에 안전하게 접근할 수 있도록 MCP(AI Agent가 외부 시스템에 접근하는 프로토콜)를 설정했다. (05:56)
  * 오픈소스 MCP 서버를 Docker로 실행하여 Gemini CLI가 알람 매니저의 데이터를 조회할 수 있도록 구성했다.
* 디스코드 연동:
  * 컴퓨터를 켜고 CLI에 직접 명령어를 입력하는 방식을 탈피하기 위해 디스코드 연동을 시도했다. (07:23)
  * 파이썬 코드와 디스코드 봇을 사용하여, 디스코드 채팅창에 입력된 명령어가 서브 프로세스(sub-process)를 통해 Gemini CLI를 직접 호출하도록 구현했다.

3. 주요 문제점 및 개선 시도

* 문제점 1: 대화 내용 기억 불가
  * 원인: 디스코드에서 채팅을 보낼 때마다 새로운 Gemini CLI 프로세스가 실행되어 이전 대화의 맥락을 전혀 기억하지 못했다. (08:14)
  * 개선 시도:
    * 파이썬 딕셔너리(Dictionary)를 사용해 이전 대화 내용을 저장하고, 새로운 질문이 들어올 때마다 저장된 대화 기록을 프롬프트에 함께 포함하여 전송하는 방식으로 개선했다. (08:14)
    * 대화 기록이 무한정 쌓이는 것을 방지하기 위해 대화 기록을 초기화하는 기능과 10분 이상 대화가 없을 시 새로운 세션으로 연결되는 기능을 추가했다.
* 문제점 2: 토큰 값 폭증 및 응답 속도 저하
  * 원인: 대화가 길어질수록 이전의 모든 질문과 답변 기록을 프롬프트에 담아 다시 전송하는 방식 때문에 토큰 사용량이 기하급수적으로 증가했다. (09:11)
  * 결과: 이로 인해 응답 속도가 눈에 띄게 느려졌으며, 오래 걸리는 작업을 요청할 경우 Gemini가 응답을 중단하는 현상까지 발생했다.

결론

* 프로젝트 평가: 모든 기능이 성공적으로 구현되지 않았기 때문에 발표자는 이 프로젝트를 '실패'로 간주한다. (10:11)
* 향후 개선 방안:
  1. API 사용: CLI 방식은 매번 새로운 프로세스를 생성하여 비효율적이므로, 챗옵스 시스템에는 API를 사용하는 것이 더 적합하다. (13:17)
  2. 보안 강화: 채팅으로 인프라를 누구나 제어할 수 있는 것은 심각한 보안 문제이므로, 사용자별 권한 부여 방안을 모색해야 한다. (13:17)
  3. 대화 관리 효율화: 토큰 문제를 해결하기 위해 대화 내용을 요약하거나, 슬라이딩 윈도우(Sliding Window) 알고리즘을 적용하여 오래된 대화는 제외하고 최근 대화만 기억하게 하는 방식의 도입이 필요하다. (14:10)

Q&A

* Q1: 파이썬으로 대화 기록을 관리하는 대신, Gemini CLI 자체에 내장된 '메모리(/memory)' 기능을 사용해 보았는가? (10:29)
  * A: 그런 기능이 있는 줄 몰랐다. 알아보겠다. (10:49)
* Q2: Gemini CLI는 1.5 플래시 모델 등을 사용하면 무료인데, 왜 토큰 할당량을 다 써서 유료로 업그레이드했는가? (12:21)
  * A: 무료 등급의 토큰을 모두 소진하여 응답이 오지 않아 등급을 올렸다. (12:24)
  * 추가 의견(질문자): 무료인 1.5 플래시 모델로도 충분할 것이며, 이를 사용하면 토큰 소모와 응답 속도 문제를 해결할 수 있을 것이다.
* Q3: 크리티컬한 문제는 어차피 메일로도 알림이 오는데, Gemini로 직접 로그를 조회하기보다 해당 메일함의 내용 안에서만 질의하거나, 알람을 DB나 노션에 쌓아두고 텍스트 검색을 하는 것이 더 가볍지 않을까? (14:50)
  * A: 좋은 방법인 것 같다. 현재 알람을 디스코드로 받고 있는데, 프로젝트가 재미있어서 계속 개선해보고 싶다. (16:25)
* Q4: 프로젝트의 최종 목표는 무엇이었나? (17:55)
  * A: 알람이 울렸을 때 디스코드에서 즉시 확인하고, 심각한 문제일 경우 채팅으로 Gemini를 호출하여 해결까지 하는 것이 목표였다. 하지만 현재 시스템은 견고하지 못하다. (18:09)
* Q5: 디스코드를 선택한 특별한 이유가 있는가? (18:36)
  * A: 슬랙 알림 봇은 만들어 본 경험이 있어서, 개인적인 흥미로 디스코드 봇을 만들어보고 싶었다. (18:46)
* Q6: 알람의 종류(예: Critical, 일반 로그)에 따라 각기 다른 채널로 알림을 보낼 수 있는가? (18:56)
  * A: 시도해보진 않았지만, 웹훅(Webhook) 기반으로 충분히 가능할 것 같다. 다만, 디스코드는 메시지당 글자 수가 2,000자로 제한되어 있어 긴 로그를 처리하는 데 한계가 있다. (19:27, 19:48)
