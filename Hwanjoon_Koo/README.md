Github App 및 AWS Lambda를 활용한 디스코드 연계 챗옵스(ChatOps) 자동화 시스템

발표주제

Github App과 AWS Lambda를 활용하여 Discord 채팅 플랫폼과 연계한 챗옵스(ChatOps) 자동화 시스템 구축

요약

반복적인 AWS 콘솔 접속 및 개발/운영 업무의 번거로움을 줄이고자 기획된 프로젝트이다. 이 시스템은 Discord 채팅 플랫폼 내에서 슬래시(/) 명령어를 통해 AWS 인프라 상태 확인, 비용 조회, 수동 배포 트리거, Github PR/Issue 알림 등의 DevOps 작업을 수행할 수 있도록 자동화한다. 핵심 기술 스택은 Discord 봇, AWS API Gateway, AWS Lambda, Github App, 그리고 AWS의 CloudWatch 및 Cost Explorer 서비스로 구성된다. 사용자가 Discord에 명령어를 입력하면 API Gateway를 통해 Lambda 함수가 호출되고, 이 함수가 Github App 및 다른 AWS 서비스와 상호작용하여 요청된 작업을 처리하고 그 결과를 Discord 채널로 다시 전송하는 구조이다.

발표내용

1. 도입 배경 및 목표

* 문제 인식: 개발 프로젝트 진행 시 AWS 콘솔에 반복적으로 접속하여 상태를 확인하거나 배포를 관리하는 과정이 번거롭고 비효율적이라고 느낌.
* 초기 기획: 처음에는 인프라 프로비저닝(VPC 설정 등)까지 채팅으로 제어하는 '전천후 에이전트'를 구상했으나, 명령어의 복잡성이 테라폼 코드를 작성하는 것과 유사해져 비현실적이라고 판단.
* 기획 수정: 프로젝트의 방향을 모니터링, 비용 확인 및 최적화, Github 연동을 통한 수동 배포 관리 등으로 전환함.
* 핵심 목표: 팀원들이 주로 소통하는 Discord 채널 내에서 주요 개발 및 운영 업무를 제어하여 효율성을 높이고, 유지보수 비용을 최소화하는 것을 목표로 설정.

2. 챗옵스(ChatOps)의 정의

챗옵스는 Discord나 Slack과 같은 채팅 플랫폼을 중심으로 개발 및 운영(DevOps) 업무를 제어하는 방식을 의미한다. 대표적인 사례로는 Github의 PR이나 이슈 발생 시 Slack으로 알림을 보내는 봇, 또는 Microsoft Teams와 Azure를 연동하여 빌드 및 배포를 관리하는 것이 있다. 이 프로젝트에서는 AWS Cost Explorer 연동을 추가하여 비용 관리 기능까지 포함시켰다.

3. 시스템 아키텍처

시스템은 Discord, Github App, AWS Lambda를 중심으로 구성된다.

* 작동 흐름:
  1. 사용자가 Discord 채널에 슬래시(/) 명령어를 입력한다.
  2. 해당 요청은 AWS API Gateway를 통해 엔드포인트 URL로 전달된다.
  3. API Gateway는 요청을 AWS Lambda 함수로 전달한다.
  4. Lambda 함수는 요청의 유효성을 검증한 후, Github App 또는 CloudWatch, Cost Explorer와 같은 다른 AWS 서비스와 통신하여 필요한 작업을 수행한다.
  5. 작업 결과를 가공하여 Discord 채널에 응답 메시지를 보낸다.
* 주요 구성 요소:
  * Github App: Github 서비스 외부(이 경우 AWS Lambda)에서 API를 호출하여 레포지토리 정보 접근, Github Action 트리거 등의 작업을 수행할 수 있도록 하는 도구. JWT 기반으로 인증하여 보안을 확보한다.
  * AWS Lambda: 서버리스 컴퓨팅 서비스로, 특정 이벤트(API 호출 등)에 따라 코드를 실행한다. EC2 서버를 직접 운영할 필요 없이 파이썬이나 Node.js 코드를 통해 AWS 서비스들을 제어하는 역할을 수행한다.

4. 주요 기능

1. /status: 인프라 상태 확인
  * 기능: AWS CloudWatch와 연동하여 EC2, ECS, EKS 등 특정 서비스의 하드웨어 상태(CPU 및 RAM 사용량)를 조회한다.
  * 사용법: /status [서비스 종류] [인스턴스 ID 또는 태그] 형식으로 명령어를 입력한다.
  * 응답 예시: EC2 ID: [ID] / Status: CPU 11%, RAM 41%와 같이 현재 리소스 사용량을 응답한다.
2. /deploy: 수동 배포 관리
  * 문제의식: PR이 특정 브랜치(dev, prod)에 머지될 때마다 자동으로 배포가 실행되면, 미완성되거나 보완이 필요한 기능이 배포될 위험이 존재.
  * 기능: /deploy approve와 같은 명령어를 통해 Github Action을 수동으로 트리거하여 배포를 시작한다.
  * 알림: 배포가 시작되면 "디플로이 디스패치됨(Deploy Dispatched)"이라는 메시지를 보내고, 배포 성공 또는 실패 시 그 결과 또한 Discord 채널로 알린다.
3. PR/Issue 자동 알림
  * 기능: Github 레포지토리에서 새로운 Pull Request(PR)가 열리거나 이슈가 생성되면, Github App과 Lambda를 통해 해당 정보를 Discord 채널에 자동으로 전송한다.
  * 효과: "PR 열었으니 봐주세요"와 같은 불필요한 소통을 줄이고, 팀원들이 코드 리뷰 등을 놓치지 않도록 돕는다.
4. 비용 알림
  * 기능: AWS Cost Explorer와 연동하여 지정된 시간(발표에서는 오전 9시로 설정)마다 현재까지 누적된 AWS 사용 비용을 계산하여 Discord 채널에 알림을 보낸다.
  * 알림 예시: "10월 1일부터 10월 17일까지 약 63달러를 사용했습니다."

5. 트러블슈팅

* 보안 문제: AWS Lambda를 호출하는 엔드포인트 URL이 외부에 노출될 경우, 무작위 공격으로 인해 과도한 비용이 발생할 수 있음.
* 무결성 검증: Discord는 ED25519라는 시그니처 검증 방식을 통해 Lambda로 들어온 요청이 유효한지를 확인하도록 요구함.
* HTTPS 엔드포인트 요구사항: Discord 정책상 HTTP가 아닌 HTTPS 엔드포인트만 허용하여, 검증 과정에서 문제가 발생.
* 해결책:
  * AWS API Gateway 도입: API Gateway를 Lambda 앞에配置하여 HTTPS 엔드포인트를 생성함. 이를 통해 Discord가 보낸 원본 요청이 인코딩/디코딩 오류 없이 Lambda로 그대로 전달되어 시그니처 검증 문제를 해결함.
  * SSM Parameter Store 활용: Github 및 Discord App의 시크릿 토큰과 같은 민감한 정보를 코드에 하드코딩하지 않고, SSM Parameter Store를 통해 안전하게 관리함.

결론

1. 기대 효과

* Discord 내에서 비용 확인, PR 처리, 인프라 상태 조회가 가능해져 개발 및 운영 효율성 증대.
* 반복적인 수동 작업을 자동화하여 유지보수 공수를 최소화.
* Github App과 Discord 봇 설치만으로 팀 프로젝트에 쉽게 적용할 수 있어 효율적인 협업 환경 구축 가능.

2. 향후 확장 계획

* /assign: PR이나 이슈에 특정 담당자를 할당하는 기능.
* 롤백 기능: 배포 실패 또는 문제 발생 시 이전 버전으로 되돌리는 기능.
* /scale: 오토스케일링 관련 설정을 제어하는 기능.
* AI 기반 비용 예측: 현재 사용량을 기반으로 월말 예상 비용을 예측하여 알림.
* IaC 도구 연동: Ansible, Terraform 등과 연동하여 보다 구체적인 인프라 구성을 챗봇으로 제어.

QnA

* 질문 1: 하드웨어 이슈(CPU 다운, RAM 오버플로우 등)로 시스템 자체가 망가졌을 때도 디스코드 봇이 상태를 체크할 수 있는가? 각 서버에 에이전트를 설치하는 방식인가?
  * 답변: 각 서버에 에이전트를 설치하는 방식이 아니다. 사용자가 Discord에 /status 명령어를 입력하면, AWS Lambda가 항상 모든 AWS 서비스를 모니터링하고 있는 CloudWatch 서비스에 데이터를 요청하여 그 결과를 가져오는 방식이다. 따라서 개별 EC2 인스턴스의 동작 여부와 관계없이 상태 조회가 가능하다.
* 질문 2: 슬래시(/) 명령어는 Discord에 내장된 기능인가?
  * 답변: 직접 만든 Discord 봇(앱)에 원하는 슬래시 명령어를 수동으로 정의할 수 있다. 명령어의 이름, 설명, 옵션 등을 JSON 형식으로 직접 작성하여 봇 서버에 등록하면, 해당 봇이 추가된 Discord 서버에서 사용할 수 있게 된다.
